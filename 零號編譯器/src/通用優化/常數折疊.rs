use std::collections::HashMap;

use crate::分詞器::Ｏ運算子;
use crate::剖析::{Ｏ句, Ｏ算式, Ｏ語法樹};

pub fn 常數折疊(語法樹: Ｏ語法樹) -> Ｏ語法樹 {
    // let mut 環境 = HashMap::<String, i64>::new();

    // let mut 答案: i64 = 0;

    // for 頂層宣告 in 語法樹.頂層宣告 {
    //     match 句 {
    //         Ｏ句::變數宣告(變數宣告) => {
    //             let 算式值 = 求值(&環境, &變數宣告.算式);
    //             答案 = 算式值;
    //             環境.insert(變數宣告.變數名, 算式值);
    //         }
    //         Ｏ句::算式(算式) => {
    //             答案 = 求值(&環境, &算式);
    //         }
    //         _ => {
    //             unimplemented!()
    //         }
    //     }
    // }

    // // 優化到語法樹裡只剩一個`算式`
    Ｏ語法樹 {
        頂層宣告: vec![]
    }
}

fn 求值(環境: &HashMap<String, i64>, 算式: &Ｏ算式) -> i64 {
    match 算式 {
        Ｏ算式::數字(數) => *數,
        Ｏ算式::變數(變數) => *環境.get(變數).unwrap(),
        Ｏ算式::二元運算(運算) => {
            let 左值 = 求值(環境, 運算.左.as_ref());
            let 右值 = 求值(環境, 運算.右.as_ref());
            match 運算.運算子 {
                Ｏ運算子::加 => 左值 + 右值,
                Ｏ運算子::減 => 左值 - 右值,
                Ｏ運算子::乘 => 左值 * 右值,
                Ｏ運算子::除 => 左值 / 右值,
                _ => unimplemented!(),
            }
        }
        Ｏ算式::施術(_) => unimplemented!(),
    }
}
