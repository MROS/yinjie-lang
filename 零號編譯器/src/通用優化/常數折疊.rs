use std::collections::HashMap;

use crate::分詞器::Ｏ運算子;
use crate::剖析::{Ｏ句, Ｏ算式, Ｏ語法樹};

pub fn 常數折疊(語法樹: Ｏ語法樹) -> Ｏ語法樹 {
    let mut 環境 = HashMap::<String, i64>::new();

    let mut 答案: i64 = 0;

    for 句 in 語法樹.句 {
        match 句 {
            Ｏ句::變數宣告(變數宣告) => {
                let 算式值 = 求值(&環境, &變數宣告.算式);
                答案 = 算式值;
                環境.insert(變數宣告.變數名, 算式值);
            }
            Ｏ句::算式(算式) => {
                答案 = 求值(&環境, &算式);
            }
        }
    }

    // 優化到語法樹裡只剩一個`算式`
    Ｏ語法樹 {
        句: vec![Ｏ句::算式(Ｏ算式::數字(答案))],
    }
}

fn 求值(環境: &HashMap<String, i64>, 算式: &Ｏ算式) -> i64 {
    match 算式 {
        Ｏ算式::數字(數) => *數,
        Ｏ算式::變數(變數) => *環境.get(變數).unwrap(),
        Ｏ算式::二元運算(運算) => {
            let 左值 = 求值(環境, 運算.左.as_ref());
            let 右值 = 求值(環境, 運算.右.as_ref());
            match 運算.運算子 {
                Ｏ運算子::加 => 左值 + 右值,
                Ｏ運算子::減 => 左值 - 右值,
                Ｏ運算子::乘 => 左值 * 右值,
                Ｏ運算子::除 => 左值 / 右值,
                _ => unimplemented!(),
            }
        }
    }
}
